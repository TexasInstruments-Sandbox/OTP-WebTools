// OTP Key Writer Error Codes
const errorCodes = [
    { bit: 0, name: "KEYWR_ERR_DECRYPT_AES256_KEY", description: "Error in Decrypting AES256 key randomly generated by customer" },
    { bit: 1, name: "KEYWR_ERR_DECRYPT_BMEK", description: "Error in Decrypting BMEK extension field" },
    { bit: 2, name: "KEYWR_ERR_DECRYPT_BMPKH", description: "Error in Decrypting BMPKH extension field" },
    { bit: 3, name: "KEYWR_ERR_DECRYPT_SMEK", description: "Error in Decrypting SMEK extension field" },
    { bit: 4, name: "KEYWR_ERR_DECRYPT_SMPKH", description: "Error in Decrypting SMPKH extension field" },
    { bit: 5, name: "KEYWR_ERR_INTERAL_OP", description: "Internal Operation Error" },
    { bit: 6, name: "KEYWR_ERR_INVALID_EXT_COUNT", description: "Invalid extension count in x509 certificate. Either SMPKH, SMEK pair or BMPKH, BMEK, SMPKH, SMEK should be used. Any other combination will trigger error" },
    { bit: 7, name: "KEYWR_ERR_PARSE_CERT", description: "Error in parsing certificate" },
    { bit: 8, name: "KEYWR_ERR_PARSE_FEK", description: "Error in parsing TI FEK (appended to TIFS binary, before encryption)" },
    { bit: 9, name: "KEYWR_ERR_PARSE_SMPK_CERT", description: "Error in parsing SMPK signed certificate (certificate that contains customer key data)" },
    { bit: 10, name: "KEYWR_ERR_PROGR_BMEK", description: "Error in programming BMEK into SoC eFuses" },
    { bit: 11, name: "KEYWR_ERR_PROGR_BMPKH_PART_1", description: "Error in programming BMPKH part 1 into SoC eFuses" },
    { bit: 12, name: "KEYWR_ERR_PROGR_BMPKH_PART_2", description: "Error in programming BMPKH part 2 into SoC eFuses" },
    { bit: 13, name: "KEYWR_ERR_PROGR_KEYCOUNT", description: "Error in programming KEY COUNT into SoC eFuses" },
    { bit: 14, name: "KEYWR_ERR_PROGR_KEYREV", description: "Error in programming KEY REV into SoC eFuses" },
    { bit: 15, name: "KEYWR_ERR_PROGR_SMEK", description: "Error in programming SMEK into SoC eFuses" },
    { bit: 16, name: "KEYWR_ERR_PROGR_SMPKH_PART_1", description: "Error in programming SMPKH part 1 into SoC eFuses" },
    { bit: 17, name: "KEYWR_ERR_PROGR_SMPKH_PART_2", description: "Error in programming SMPKH part 2 into SoC eFuses" },
    { bit: 18, name: "KEYWR_ERR_VALIDATION_CERT", description: "Error validating certificate" },
    { bit: 19, name: "KEYWR_ERR_VALIDATION_SMPK_CERT", description: "Error validating SMPK signed certificate" },
    { bit: 20, name: "KEYWR_ERR_VALIDATION_BMPK_KEY", description: "Error validating BMPK key" },
    { bit: 21, name: "KEYWR_ERR_VALIDATION_SMPK_KEY", description: "Error validating SMPK key" },
    { bit: 22, name: "KEYWR_ERR_WRITE_PROT_KEYCOUNT", description: "Error write protecting key count row" },
    { bit: 23, name: "KEYWR_ERR_WRITE_PROT_KEYREV", description: "Error write protecting key revision row" },
    { bit: 24, name: "KEYWR_ERR_IMG_INTEG_SMPK_CERT", description: "SMPK signed certificate image integrity failed" },
    { bit: 25, name: "KEYWR_ERR_PROGR_MSV", description: "Error in programming MSV into SoC eFuses" },
    { bit: 26, name: "KEYWR_ERR_PROGR_SWREV", description: "Error in programming SWREV into SoC eFuses" },
    { bit: 27, name: "KEYWR_ERR_PROGR_FW_CFG_REV", description: "Error in programming FW CFG REV into SoC eFuses" },
    { bit: 28, name: "KEYWR_ERR_DECRYPT_EXT_OTP", description: "Error in Decrypting EXT OTP extension field" },
    { bit: 29, name: "KEYWR_ERR_PROGR_EXT_OTP", description: "Error in programming EXT OTP extension field" },
    { bit: 30, name: "KEYWR_ERR_PROGR_OVERRIDE", description: "Error in programming existing field without override specified" },
    { bit: 31, name: "KEYWR_ERR_JTAG_DISABLE", description: "Error in programming JTAG DISABLE field" }
];

// DOM Elements
const errorCodeInput = document.getElementById('errorCode');
const decodeBtn = document.getElementById('decodeBtn');
const clearBtn = document.getElementById('clearBtn');
const resultsSection = document.getElementById('resultsSection');
const resultsContainer = document.getElementById('resultsContainer');
const referenceTableBody = document.getElementById('referenceTableBody');

// Initialize the page
function init() {
    populateReferenceTable();
    decodeBtn.addEventListener('click', decodeErrorCode);
    clearBtn.addEventListener('click', clearResults);
    errorCodeInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            decodeErrorCode();
        }
    });
}

// Populate the reference table
function populateReferenceTable() {
    errorCodes.forEach(error => {
        const row = document.createElement('tr');
        const hexValue = '0x' + ((1 << error.bit) >>> 0).toString(16).toUpperCase().padStart(8, '0');

        row.innerHTML = `
            <td class="bit-cell">${error.bit}</td>
            <td class="hex-cell">${hexValue}</td>
            <td class="error-name-cell">${error.name}</td>
            <td>${error.description}</td>
        `;

        referenceTableBody.appendChild(row);
    });
}

// Parse input value to decimal
function parseInput(input) {
    const trimmed = input.trim();

    if (!trimmed) {
        throw new Error('Please enter an error code');
    }

    let value;

    // Hexadecimal (0x prefix)
    if (trimmed.toLowerCase().startsWith('0x')) {
        value = parseInt(trimmed, 16);
    }
    // Binary (0b prefix)
    else if (trimmed.toLowerCase().startsWith('0b')) {
        value = parseInt(trimmed.slice(2), 2);
    }
    // Decimal
    else {
        value = parseInt(trimmed, 10);
    }

    if (isNaN(value)) {
        throw new Error('Invalid input format. Please use decimal, hex (0x), or binary (0b) format.');
    }

    if (value < 0) {
        throw new Error('Error code cannot be negative');
    }

    if (value > 0xFFFFFFFF) {
        throw new Error('Error code exceeds 32-bit range');
    }

    return value;
}

// Decode the error code
function decodeErrorCode() {
    try {
        const input = errorCodeInput.value;
        const errorValue = parseInput(input);

        // Find which bits are set
        const setBits = [];
        for (let i = 0; i < 32; i++) {
            if (errorValue & (1 << i)) {
                setBits.push(i);
            }
        }

        displayResults(errorValue, setBits, input);

    } catch (error) {
        displayError(error.message);
    }
}

// Display the decoded results
function displayResults(errorValue, setBits, originalInput) {
    resultsContainer.innerHTML = '';

    // Display input information
    const inputInfo = document.createElement('div');
    inputInfo.className = 'input-info';
    inputInfo.innerHTML = `
        <strong>Input:</strong> ${originalInput} |
        <strong>Decimal:</strong> ${errorValue} |
        <strong>Hex:</strong> 0x${errorValue.toString(16).toUpperCase().padStart(8, '0')} |
        <strong>Binary:</strong> 0b${errorValue.toString(2).padStart(32, '0')}
    `;
    resultsContainer.appendChild(inputInfo);

    if (setBits.length === 0) {
        const noErrorCard = document.createElement('div');
        noErrorCard.className = 'error-card no-errors';
        noErrorCard.innerHTML = `
            <div class="error-header">
                <div class="error-name">No Errors Detected</div>
            </div>
            <div class="error-description">The error code is 0 (no bits set), indicating no errors.</div>
        `;
        resultsContainer.appendChild(noErrorCard);
    } else {
        setBits.forEach(bit => {
            const error = errorCodes.find(e => e.bit === bit);
            if (error) {
                const errorCard = document.createElement('div');
                errorCard.className = 'error-card';
                errorCard.innerHTML = `
                    <div class="error-header">
                        <div class="error-name">${error.name}</div>
                        <div class="error-bit">Bit ${error.bit}</div>
                    </div>
                    <div class="error-description">${error.description}</div>
                `;
                resultsContainer.appendChild(errorCard);
            }
        });
    }

    resultsSection.style.display = 'block';
    resultsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Display error message
function displayError(message) {
    resultsContainer.innerHTML = '';

    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.textContent = message;
    resultsContainer.appendChild(errorDiv);

    resultsSection.style.display = 'block';
    resultsSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Clear results
function clearResults() {
    errorCodeInput.value = '';
    resultsContainer.innerHTML = '';
    resultsSection.style.display = 'none';
    errorCodeInput.focus();
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', init);
